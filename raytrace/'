import logging
import math
import warnings

import numpy as np

logger = logging.getLogger(__name__)

class NonIntersectingRayError(Exception):
    pass

def siddonraytracer(vols, source, target, start, spacing):
    """Siddon raytracer for calculating intersection positions and lengths for rays coincident with
    a subdivided cube (of voxels)

    Args:
        vols: asdf
        src: asdf
        dst: asdf
        start: asdf
        spacing: asdf
    """
    if isinstance(vols, np.ndarray):
        vols = [vols]
    size = np.array(vols[0].shape[::-1])
    Nplanes = size+1
    start = np.array(start)
    spacing = np.array(spacing)
    source = np.array(source)
    target = np.array(target)
    assert len(start) == 3
    assert len(spacing) == 3
    assert source.shape == target.shape

    # number of intersection planes
    Nx, Ny, Nz = Nplanes
    diff = target - source
    raylength = np.linalg.norm(diff)

    empty_result = ([], [], [list() for _ in range(len(vols))], raylength, [])

    # boundary plane positions (eq 3)
    first_plane = start - spacing/2 # indices are defined at voxel center
    last_plane  = first_plane + size*spacing

    # parametric boundary values (eq 4)
    with np.errstate(divide='ignore'):
        alpha_first = (first_plane-source)/diff
        alpha_last = (last_plane-source)/diff
        # resolve errors so alpha_min and alpha_max are still valid
        alpha_first[~np.isfinite(alpha_first)] = -float('inf')
        alpha_last[~np.isfinite(alpha_last)] = float('inf')

    # ray entrance/exit parameter values (eq 5)
    alpha_min = np.amax(np.maximum(0, np.minimum(alpha_first, alpha_last)))
    alpha_max = np.amin(np.minimum(1, np.maximum(alpha_first, alpha_last)))

    logger.debug('source:      {}'.format(source))
    logger.debug('target:      {}'.format(target))
    logger.debug('start:       {}'.format(start))
    logger.debug('diff:        {}'.format(diff))
    logger.debug('raylength:   {}'.format(raylength))
    logger.debug('first_plane: {}'.format(first_plane))
    logger.debug('last_plane:  {}'.format(last_plane))
    logger.debug('alpha_first: {}'.format(alpha_first))
    logger.debug('alpha_last:  {}'.format(alpha_last))
    logger.debug('alpha_min:   {}'.format(alpha_min))
    logger.debug('alpha_max:   {}'.format(alpha_max))

    if alpha_max <= alpha_min:
        raise NonIntersectingRayError()

    # calcualate intersection plane indices (eq 6)
    imin = np.zeros((3,))
    imax = np.zeros((3,))
    for ax in range(3):
        if diff[ax] >=0:
            imin[ax] = math.ceil( size[ax] - (last_plane[ax] - alpha_min*diff[ax] - source[ax])/spacing[ax] )
            imax[ax] = math.floor( (source[ax] + alpha_max*diff[ax] - first_plane[ax])/spacing[ax] )
        else:
            imin[ax] = math.ceil( size[ax] - (last_plane[ax] - alpha_max*diff[ax] - source[ax])/spacing[ax] )
            imax[ax] = math.floor( (source[ax] + alpha_min*diff[ax] - first_plane[ax])/spacing[ax] )

    logger.debug('imin: {}'.format(imin))
    logger.debug('imax: {}'.format(imax))

    # generate per-axis param lists (eq 7)
    alphas = set([alpha_min, alpha_max])
    for ax in range(3):
        if diff[ax] != 0:
            alphas.update( ((first_plane[ax] + np.arange(imin[ax], imax[ax]+1, 1)*spacing[ax]) - source[ax])/diff[ax] )
        else:
            pass
    alphas = list(alphas)
    alphas.sort()
    logger.debug('alphas: {}'.format(alphas))

    # calculate voxel intersection lengths (eq 10)
    lengths = raylength*np.diff(alphas)
    logger.debug('lengths: {}'.format(lengths))

    # calculate intersection midpoints (eq 13)
    alpha_arr = np.array(alphas)
    alpha_mids = (alpha_arr[:-1]+alpha_arr[1:])/2
    logger.debug('alpha_mids: {}'.format(alpha_mids))

    # calculate voxel indices (eq 12)
    indices = np.empty((len(alpha_mids), 3), dtype=int)
    for ax in range(3):
        indices[:, ax] = np.floor( (source[ax] + alpha_mids*diff[ax] - first_plane[ax])/spacing[ax] )
    logger.debug('indices: {}'.format(indices))

    # read densities corresponding to indices
    try:
        densities = []
        for ii, vol in enumerate(vols):
            d = vol[indices[:, 2], indices[:, 1], indices[:, 0]]
            densities.append(d)
            logger.debug('densities ({}): {}'.format(ii, d))
    except IndexError:
        raise NonIntersectingRayError()
    logger.debug('')

    return (alphas, lengths, densities, raylength, indices)

def spottrace(sad, det_dims, det_center, det_spacing, det_pixelsize, det_azi, det_zen, det_ang, vols, vol_start, vol_spacing):
    """Emulates the diverging square beam geometry of proton beams. Unlike beamtrace(), this function
    produces the minimum and maximum radiological path length for each closed segment of the target
    mask intersecting with each ray. From this information, a set of proton pencil beam energies can
    be derived for constructing a scanning-spot-style of proton beam delivery.

    Args:
        sad (float):                             distance from source to isocenter (equivalently: focal point to center of detector plane)
        det_dims (int_x, int_y):                 number of detector elements
        det_center (float_x, float_y, float_z):  coordinates of detector plane center
        det_spacing (float_x, float_y):          spacing between adjacent detector elements (not the same as element size)
        det_pixelsize (float_x, float_y):        element size
        det_azi:                                 angle (radians) of azimuth (linac gantry angle)
        det_zen:                                 angle (radians) of zenith (linac couch angle)
        det_ang:                                 angle (radians) of detector plane rotation around its normal vector (linac collimator rotation)
        density_vol:                             density volume containing voxels through which to raytrace
        mask_vol:                                binary volume containing mask definition
        vol_start (float_x, float_y, float_z):   coordinates of center of first voxel in vol
        vol_spacing (float_x, float_y, float_z): spacing between adjacent voxels in volume (assumes direct adjacency)
    """


    """
    returns [[]]
    """


    depths = []
    for rr in range(det_dims.shape[1]):
        rowdepths = []
        for cc in range(det_dims.shape[0]):
            coldepths = []
            for group in range(10):
                coldepths.append((0,1))
            rowdepths.append(coldepths)
        depths.append(rowdepths)
    print(depths)
    return depths


